## ❓ 问题复述

**一个无尽队列（无限制生产请求）不断向线程池提交任务，可能会出现什么现象？**

---

## ✅ 面试考察点

这个问题主要考察你对以下几点的理解：

* **线程池结构**（线程数、任务队列）
* **内存管理和系统资源限制**
* **并发与阻塞机制**
* **限流和拒绝策略**

---

## 🚨 可能出现的现象（从轻到重）

### 1. **任务队列无限增长，内存飙升**

* 如果任务提交速度 > 线程池处理速度，任务在队列中排队。
* 没有队列大小限制 ➜ 队列会不断增长 ➜ 占用越来越多内存 ➜ 进程或系统崩溃（OOM）。

### 2. **线程池卡死或响应变慢**

* 如果任务本身执行耗时长（例如 I/O 密集），线程池无法及时消费队列。
* 用户感知延迟变高 ➜ 系统“假死”。

### 3. **CPU 资源被挤占**

* 如果线程数设置太高，频繁上下文切换 ➜ CPU 开销巨大 ➜ 整个系统变慢。

### 4. **系统崩溃 / 被 OOM Killer 杀死**

* 随着队列增长，系统内存被耗尽 ➜ 被操作系统强制回收 ➜ **程序异常退出**。

---

## 🛡️ 解决策略 / 面试建议回答方向

### A. **设置线程池的任务队列上限**

* 典型设计：固定大小的阻塞队列。
* 提交任务时，如果队列已满，要么阻塞调用者，要么拒绝。

### B. **拒绝策略（Rejection Policy）**

常见策略有：

* **丢弃任务**（Discard）
* **抛出异常**
* **调用者执行（CallerRuns）**
* **记录日志告警**

### C. **限流、背压机制**

* 控制任务生产速度（限速器 / Rate Limiter）
* 加入**令牌桶**或**漏桶**机制控制提交速率

### D. **监控和自适应调度**

* 实时监控任务堆积数量、处理速率
* 根据负载自动调整线程池大小（如 ThreadPoolExecutor 中的 scaling）

---

> 如果一个无限任务队列持续向线程池提交请求，而线程池没有限制队列长度或处理能力跟不上，将导致任务堆积、内存持续增长，最终可能引发 OOM。为了解决这个问题，线程池应设置合理的任务队列上限并配合拒绝策略，或引入限流机制，如令牌桶/漏桶等控制提交速率，防止系统过载。

---

* 队列使用 `std::queue` + `mutex/condition_variable`
* 你可以加一个最大长度控制，比如 `std::condition_variable::wait` 限制提交频率