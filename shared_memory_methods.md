共享内存（Shared Memory）是**进程间通信（IPC）**的一种高效方式，它允许多个进程**共享一块物理内存区域**，从而实现高速通信。我们来系统地讲一下：

---

## ✅ 一、共享内存的类型（按实现方式分类）

| 类型                          | 描述                                 | 使用场景 / 接口                                   |
| --------------------------- | ---------------------------------- | ------------------------------------------- |
| **System V 共享内存**           | 老式、功能强大、结构复杂                       | 使用 `shmget`, `shmat`, `shmdt`, `shmctl`     |
| **POSIX 共享内存**              | 新标准、易用、可用文件名标识                     | 使用 `shm_open`, `mmap`, `ftruncate`, `close` |
| **匿名内存映射（匿名 mmap）**         | 无文件关联，仅用于父子进程                      | 使用 `mmap(MAP_ANONYMOUS)`                    |
| **内存映射文件（mmap 文件共享）**       | 基于文件的共享内存                          | 使用 `mmap` 映射一个文件                            |

---

## 🛠️ 二、各类型的使用方式简要

### 1. 🔧 System V 共享内存（传统）

```c
// 创建共享内存段
int shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0666);

// 映射到当前进程地址空间
void* ptr = shmat(shmid, NULL, 0);

// 解除映射
shmdt(ptr);

// 删除共享内存段
shmctl(shmid, IPC_RMID, NULL);
```

* 缺点：接口繁琐，需手动管理权限和 key
* 优点：在老系统上兼容性好

---

### 2. 🚀 POSIX 共享内存（推荐使用）

```c
// 创建共享内存对象（名字像文件路径）
int fd = shm_open("/myshm", O_CREAT | O_RDWR, 0666);
ftruncate(fd, size); // 设置大小

// 映射到内存
void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

// 使用完关闭和解除映射
munmap(ptr, size);
close(fd);
shm_unlink("/myshm");
```

* 优点：可命名、可跨进程、用法像文件，易于管理
* 缺点：创建和清理需注意，默认存在于 `/dev/shm`

---

### 3. 💡 匿名 mmap（父子进程通信）

```c
void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                 MAP_SHARED | MAP_ANONYMOUS, -1, 0);
```

* 只能用于 **fork 后的父子进程间通信**
* 不能跨无血缘关系的进程

---

## 🌟 三、共享内存的特性总结

| 特性              | 描述               |
| --------------- | ---------------- |
| 🔄 **高效**       | 不涉及内核态和用户态数据拷贝   |
| ⚠️ **无同步机制**    | 需要配合信号量、互斥锁等机制使用 |
| 📌 **跨进程共享**    | 多进程可以访问同一内存区域    |
| 🧽 **需手动释放**    | 如果不释放，共享内存可能长期驻留 |
| 🧩 **可结合 mmap** | 和文件系统结合用于持久化共享   |

---

## 🚫 注意事项

* 使用共享内存时，需要通过 **信号量 / 互斥锁** 来保证同步，否则可能产生数据竞争（race condition）

---
