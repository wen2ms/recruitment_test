# 1. 网络模型

## 1.1 七层网络模型
OSI`Open Systems Interconnection`七层模型。

1. 物理层：通过链路进行比特传输。
2. 数据链路层：将数据封装成帧和差错控制，协议包括以太网`Ethernet`，`MAC`。
3. 网络层：路由。例如`IP`协议。
4. 传输层：端到端的通信。`TCP, UDP`。
5. 会话层：建立，管理和断开会话。
6. 表示层：数据格式转化`JPEG`，加解密`SSL/TLS`。
7. 应用层：`HTTP, FTP, SMTP`。

## 1.2 五层模型

1. 物理层：比特传输。
2. 链路层：以太网帧，`WiFi`。
3. 网络层：`IP, ARP`。
4. 传输层：`TCP, UDP`。
5. 应用层：`HTTP, DNS, FTP`。

### 1.3 四层模型

链路层，网络层，传输层，应用层。

# 2. 连接与断开的过程

## 2.1 TCP报文结构

|               字段               | 长度  |
| :------------------------------: | :---: |
|              源端口              | 2字节 |
|             目的端口             | 2字节 |
|              `seq`               | 4字节 |
|              `ack`               | 4字节 |
|       TCP报文段头部的长度        |  4位  |
| 标志位`Flags (ACK, FIN, SYN...)` |  9位  |
|              `rwnd`              | 2字节 |
|    校验和（检查报文段完整性）    | 2字节 |
|   可选字段（`MSS, Timestamp`）   | 可变  |

`TCP`报文段头部至少20个字节，而`UDP`报文头部是固定的8字节。

## 2.2 三次握手

三次握手是用来建立连接的，过程如下

```
客户端（Client）                                   服务端（Server）

SYN_SENT      | --------- SYN seq=x ----------> |
              |                                 |
              | <--- SYN + ACK seq=y ack=x+1 -- | SYN_RECIEVED
              |                                 |
ESTABLISHED   | --------- ACK ack=y+1 --------> | 
              |                                 |ESTABLISHED
```

1. 第一次握手：客户端向服务端发送一个`SYN`报文段，进入`SYN_SENT`状态，`SYN`报文中包含初始序列号`seq = x`。
1. 第二次握手：服务端收到客户端发来的`SYN`报文段，回复`SYN + ACK`报文段，其中`SYN`报文段中包含服务端的初始序列号`seq = y`和确认客户端的序列号`ack = x + 1`表示确认收到，服务端进入`SYN_RECIEVED`状态。
1. 第三次握手：客户端接收到服务端发来的`SYN + ACK`报文段，再回复给服务端`ACK`报文段，表示收到，其中`ack = y + 1`，然后客户端变为`ESTABLISHED`状态，随后服务端收到`ACK`报文段后也进入`ESTABLISHED`。至此三次握手建立连接成功。
1. 此后的每一次连接都需要确认对方上次发送的数据。

## 2.3 四次挥手

四次挥手是双方各自独立的断开连接：

````
客户端（Client）                          服务端（Server）

FIN_WAIT_1    | --------- FIN seq=u ----------> |
    					|                                 |
					    | <---------- ACK ack=u+1 ------- | CLOSE_WAIT
FIN_WAIT_2    |                                 |
              | <--------- FIN seq=v ---------- | LAST_ACK
				      |                                 |
TIME_WAIT     | ----------- ACK ack=v+1 ------> |
              |                                 | CLOSED
CLOSED        |                                 |
````

1. 第一次挥手：客户端向服务端发送一个`FIN seq = u`报文段，表示数据发送完毕，不再发送。客户端进入`FIN_WAIT_1`。
2. 第二次挥手：服务端接收到`FIN`报文段后，回复一个确认报文段`ACK ack = u + 1`，然后进入`CLOSE_WAIT`状态。在客户端收到`ACK`报文段后进入`FIN_WAIT_2`。
3. 第三次挥手：服务端不再发送数据，发送`FIN seq = v`报文段，进入`LAST_ACK`状态。
4. 第四次挥手：客户端接收到`FIN`报文段后，回复一个确认报文段`ACK ack = v + 1`，然后进入`TIME_WAIT`状态，等待`2MSL`时间，来确保`ACK`报文段。服务端接收到`ACK`报文段后关闭连接，在客户端等待完成后也关闭连接。至此，双方断开连接成功。这里`2MSL  (Maximum Segment Lifetime)`代表TCP报文段在网络中允许存活的最大时间的两倍，客户端发送的`ACK`最长`1MSL`到达服务端，同时服务端重传的`FIN`最长也是`1MSL`，因此`2MSL`保证了这一点。

# 3. 常见的问题
##  3.1 三次挥手

四次挥手一般无法无法缩减成三次。

如果要变成三次挥手，就是将第二次挥手中服务端发送`ACK`报文段和第三次挥手发送自己的`FIN`合并成一步，但问题在于两个报文段表示的含义不同，`ACK`报文段表示接收到客户端发来的`FIN`报文段，而自己的`FIN`报文段表示服务端自己不再发送数据，显然这两个状态没有关联，往往服务端是在不同时间再确定结束发送数据的。

即使服务端在第二次挥手的时候真的没有数据发送了，将四次挥手变成三次，但逻辑上其实也是四次挥手。本质上四次挥手代表了双方各自独立的断开连接。

## 3.2 客户端意外断开

如果客户端在连接时没有通过四次挥手断开连接，而是意外断开，例如客户端断电，进程崩溃，断网等问题，会出现：

### 3.2.1 资源泄漏，降低性能

1. 服务端不知道客户端已经断线，则会继续占用`socket`，也就是文件描述符`fd`，同时会保留这个`TCP`连接的内核状态，例如`TCP`状态控制块`TCB`，读/写缓冲区，超时重传计时器。这个连接已经属于死连接，如果死连接过多，将会占用更多的文件描述符和内存，甚至有可能导致`fd`耗尽，进而无法接受新连接。
2. 服务端不断重传因没有接受到而发送失败的数据包，这些数据包会占用网络带宽，但没有任何主机会接受这些包，有可能导致链路拥塞，同时增加延迟。
3. 如果服务端开启了`TCP KeepAlive`，用来检测连接的另一端是否存活，当一个连接长时间没有任何数据传输时，内核会发送一个`KeepAlive`探测包，如果客户端存活则会回复一个`ACK`包，否则经过一定次数的探测后，内核确定连接已经死亡，在`linux`中内核会默认2小时后探测客户端是否断开连接，时间过长。

### 3.2.2 解决方法

1. 启动`TCP KeepAlive`并缩短探测时间，探测间隔和失败次数。
2. 在应用层加入心跳机制，如在`MQTT`中规定双方每隔30秒发送一次心跳包。

## 3.3 重复请求

网络抖动导致之前的`SYN`报文段延迟到达；客户端重传第一次握手的`SYN`报文段；客户端重复启动，发送了相同的请求，都有可能导致重复请求。

而三次握手的机制可以处理重复请求的接收。关键就在于服务端在收到一个客户端发来的`SYN seq=x`报文段后，回复`SYN + ACK seq=y, ack=x+1`报文段后，就进入了`SYN_RECIEVED`状态了，此时接受到新的`SYN`报文段也不会回复了。而如果是旧的报文段`SYN seq=w`先到了，那么服务端会发送`SYN + ACK seq=y, ack=w+1`，客户端期望得到的是`ACK ack=x+1`，因此不会回复`ACK ack=y+1`，然后在服务端超时之后就会把这个半连接断开。

同时`TCP`的一个连接是由`<源IP, 源端口，目标IP，目标端口>`这个四元组确定的，源`IP`，目标`IP`和目标端口一般是确定的，但源端口，也就是客户端端口一般是由操作系统临时分配的，保证客户端重新连接时不会被认为是同一个连接。

## 3.4 大量CLOSE_WAIT连接

当客户端发送`FIN`报文段后，服务端回复`ACK`报文段后，服务端就进入了`CLOSE_WAIT`状态，但此时服务端进程没有调用`close`来关闭`fd`的连接。

我们可以通过：

```sh
netstat -antp | grep CLOSE_WAIT

ss -antp | grep CLOSE_WAIT

lsof -i | grep CLOSE_WAIT 
```

查到哪一个进程`pid`导致的。

解决方案可以在程序中设置空闲时间的超过一定阈值就主动调用`close`。

## 3.5 TCP粘包

TCP是面向连接的流式传输协议，它的传输单位是报文段，但应用层看到的只是字节流，没有规定消息边界，因此接收方在读取的时候会将多个数据包合并在一起。

例如客户端连续发送两条消息`hello`和`world`，服务端一次性接受`recv(1024)`，那么收到的数据是`helloworld`，无法分开。

解决方案就是让服务端知道消息边界，例如：

1. 客户端发送的每个数据包前加入4个字节数据的长度，例如`[0005]hello[0005]world`，服务端先接收长度，然后根据长度读取数据包。
2. 在数据末尾加入分隔符`\r\n`，服务端接收到`\r\n`就认为一部分结束。
3. 应用层协议，例如`HTTP/1.1`通过请求行，请求头，空行，请求体，每个部分用`\r\n`来分割，通过`Content-Length`来说明请求体的长度。

# 4. 拥塞控制和流量控制

## 4.1 拥塞控制

拥塞控制`Congestion Control`是为了防止发送方发送数据时过多产生网络拥塞。

1. 慢启动：初始的拥塞窗口`cwnd = 1MSS`。`cwnd (congestion window)`表示当前允许发送的数据量，`MSS (Maximum Segment Size)`表示每个报文段数据的最大值，不含报文段头部。每收到一个`ACK`报文段就让`cwnd += 1MSS`，因此每个每隔一个数据包的来回时间`RTT (Round Trip Time)`，`cwnd`的就会翻倍。
2. 拥塞避免：当慢启动产生的`cwnd >= ssthresh`，其中`sshthresh (slow start threshold)`是慢启动阈值，就会切换到拥塞避免算法，每个`RTT`，拥塞窗口线性增长`++cwnd`。
3. 快重传机制：接收方不要等到自己发送数据的时候才发送`ACK`报文段，而是接收到数据的时候就直接发送`ACK`报文段。其次就是当收到失序的报文段要发出已经收到的报文段的重复确认`ACK`，最后发送方当收到三个重复的`ACK`报文段后，立刻重传，不再等候超时重传计时器超时。
4. 快恢复机制：当触发快重传时，就认为是网络拥塞了，那么就将慢启动阈值`sshthresh`和拥塞窗口`cwnd`设置成当前`cwnd`的一半，开始执行拥塞避免算法。
5. 如果是超时重传会将`ssthresh`设置成当前`cwnd`的一半，并将`cwnd = 1MSS`，然后重新执行慢启动算法。

## 4.2 流量控制

流量控制`Flow Control`控制的是发送方发送数据的速率防止接收方来不及接收。它的核心是使用滑动窗口。

当客户端在与服务端建立TCP连接时，服务端会向客户端发送自己的接收窗口`rwnd`，客户端将自己的发送窗口`swnd = min(rwnd, cwnd)`，这里假设`swnd = rwnd`，然后客户端向服务端依次发送`1MSS`的TCP报文段，当服务端收到后会回复客户端自己已经收到的报文段的累积确认`ACK`，其中包含了`rwnd`，然后客户端将已经被确认的数据移除发送窗口，释放已经确认的数据，同时根据`rwnd`继续调整`swnd`，这里如果发送的报文段丢失了，那么下次发送还是从上次发送的下一个位置发送，丢失的部分由超时重传来负责，以此类推。

当服务端的读缓冲区已满，它会回复客户端`rwnd = 0`，客户端移动发送窗口后，也停止发送数据。一旦服务端腾出空间就会发送一个`ACK`告诉客户端可以发送数据了，为了防止这个`ACK`丢失引起的死锁现象，客户端在接收`rwnd = 0`以后就会发送零窗口探测包，接收方即使`rwnd = 0`也还是会回复`ACK`。

这里不能通过接收方回复接收速率来代替`rwnd`，因为速率是很难控制，并且滑动窗口的机制天然适用于面向字节流的TCP。

## 4.3 滑动窗口

滑动窗口实际上指的就是在发送数据的时候不需要等待上一个发送的报文段的`ACK`到达，而直接连续发送多个数据包，同时使用流量控制和拥塞控制对`swnd`进行限制，理论的吞吐量就等于`swnd * RTT`。

# 5. Json与protobuf

`Json`本质就是文本，包含`key`和`value`按照字节编码。而`protobuf`是二进制编码，它不需要存储字段名，序列化后数据比`Json`小很多。在频繁的网络通信中能显著减少网络带宽，而且反序列化时的解析速度更快。

`Json`的字段是没有约束的，在状态驱动的通信中使用`protobuf`定义好的`.proto`可以保证双方严格遵守协议。

为了保证`protobuf`的消息被解析出需要利用`libprotobuf`手动的进行解析，因为`Json`中传送的是人类可见字符，而`protobuf`处理过的字符是二进制字符。
