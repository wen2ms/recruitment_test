### 一、什么是 TCP 粘包？

**TCP 粘包（Sticky Packet）** 是由于 TCP 是面向字节流（Stream）的协议，没有消息边界，因此在接收方读取数据时，**可能会把多个发送的数据包合并在一起读取**，这就叫做粘包。

#### 举个例子：

假设客户端连续发送两个消息：

* 消息1："Hello"
* 消息2："World"

如果接收端一次性 `recv(1024)`，可能会收到：

* “HelloWorld” —— 两个消息粘在一起（粘包）
* “Hel” 和 “loWorld” —— 被拆开了（拆包）
* “Hello” 和 “World” —— 正常（不粘不拆）

### 二、为什么会出现粘包？

TCP 粘包/拆包可能发生的原因有：

1. **TCP 是流式协议**：没有消息边界，数据按字节流传输。
2. **发送方写入数据太快**：应用连续 `send()` 两次，底层合并了两个包。
3. **接收方 `recv()` 不及时或读取长度不合适**：可能读取到不完整或多个消息。

### 三、怎么解决粘包问题？

解决 TCP 粘包/拆包的核心思路是：**让接收方知道消息边界**。

常用的方法有以下几种：

---

#### ✅ 方法一：**固定长度协议**

每条消息定长（如每条消息都是 128 字节），接收端每次读取固定字节数。

* 优点：简单易实现。
* 缺点：浪费空间，不灵活。

---

#### ✅ 方法二：**分隔符协议**

在每个消息后加特殊字符，如 `\n` 或 `|END|` 来标识结束。

* 例子：

  * 消息1：`Hello\n`
  * 消息2：`World\n`

* 接收端按分隔符拆分消息。

* 优点：实现简单。

* 缺点：消息内容中不能包含分隔符（或需转义）。

---

#### ✅ 方法三：**长度前缀协议（常用）**

每条消息前加上固定长度的头部（如 4 字节），用于表示消息体长度。

* 例子：

  * `[0005]Hello[0005]World`  （前 4 字节是消息长度）

* 接收端先读长度，再根据长度读取完整消息。

* 优点：灵活，广泛使用（如很多 RPC 协议使用该方法）

* 缺点：实现稍复杂，需要缓冲区和拆包逻辑。

---

#### ✅ 方法四：**使用高级协议框架**

如：

* Python：`struct` 模块构造二进制协议，或使用 `protobuf`、`msgpack` 等。
* 网络框架如 Netty（Java）、Twisted（Python）等都有内置拆包器。

---

### 四、总结

| 方式      | 原理          | 优点    | 缺点          |
| ------- | ----------- | ----- | ----------- |
| 固定长度    | 每条消息长度固定    | 简单    | 浪费空间，不灵活    |
| 分隔符     | 使用特殊字符分隔消息  | 简单    | 不适合包含分隔符的数据 |
| 长度前缀    | 消息前添加长度字段   | 灵活，常用 | 实现稍复杂       |
| 高级协议/框架 | 使用现成协议或框架封装 | 可靠，高效 | 依赖外部库       |
