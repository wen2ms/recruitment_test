默认情况下，网卡（Network Interface Card）收到一个网络包后，系统会经历以下步骤，逐层上送到应用层（以 Linux 为例说明）：

---

### 1. **网卡收到数据包**

* 网卡硬件通过物理链路（如以太网）接收到网络包（比如一个 TCP/IP 包）。

---

### 2. **驱动程序处理**

* 网卡将包传给对应的**驱动程序**。
* 驱动程序将数据放入内核的缓冲区（比如 **ring buffer**），并触发一个**硬件中断**，告诉内核“我有包要处理”。

---

### 3. **内核网络协议栈处理**

内核根据包的协议类型进行逐层处理：

#### a. **数据链路层（如 Ethernet）**

* 检查目的 MAC 地址是否是本机或广播。
* 去除以太网帧头部，将数据交给上一层（网络层）。

#### b. **网络层（如 IP）**

* 解析 IP 头部，检查目标 IP 是否是本机。
* 根据协议字段判断下一层是 TCP、UDP 还是其他协议。
* 去除 IP 头，转交给传输层。

#### c. **传输层（如 TCP/UDP）**

* 检查目标端口号（如 80、443、5000）。
* 查找是否有相应的 socket 在监听该端口（socket 查找）。
* 若是 TCP，还要做序号检查、重组等。
* 数据转交给应用层 socket 缓冲区（**sk\_buff** 最终进入用户空间）。

---

### 4. **唤醒/通知用户态应用程序**

* 应用程序通过 `recv`、`read` 等系统调用接收数据。
* 如果数据到达时应用正在阻塞接收，就被唤醒；否则，下次调用时直接读缓存。

---

### 简化流程图如下：

```
[网卡] → [驱动] → [中断] → [协议栈 (Eth → IP → TCP/UDP)] → [socket 缓存] → [应用层]
```

---

### 总结一句话：

> 默认情况下，网卡收到包后，触发中断、经内核网络协议栈逐层解析，匹配 socket，并将数据拷贝进应用层的接收缓冲区，等待应用读取。

## 一、什么是“数据封装”？

网络通信遵循 **OSI 七层模型** 或简化的 **TCP/IP 四层模型**，数据从发送端到接收端，经历了逐层“封装”和“解封装”的过程：

### 👉 封装（发送方向下传）

发送端从应用层到物理层，每一层**在数据前面加上自己的“头部信息”**：

```
应用数据 → 加应用层头部（如 HTTP）
         → 加传输层头部（如 TCP）
         → 加网络层头部（如 IP）
         → 加数据链路层头部（如 MAC）
         → 发送给网卡
```

每一层负责自己的功能，比如：

* TCP：端口号、可靠传输
* IP：IP 地址、路由选择
* MAC：局域网寻址

---

### 👉 解封装（接收方向上传）

当驱动程序从网卡收到一个数据包（比如以太网帧），**内核网络协议栈从最底层开始一层一层“剥离头部”**：

```
收到的数据帧
→ 去掉 MAC 头，进入 IP 层（网络层）
→ 去掉 IP 头，进入 TCP 层（传输层）
→ 去掉 TCP 头，送给应用层（如 HTTP）
```

**每一层都只关心自己那层的头部，并决定是否继续上传或丢弃。**

---

## 二、流程图解（简化版）

```
┌────────────┐             应用层（HTTP、FTP）
│ 应用数据包 │ ←───────┐
└────────────┘        │
       ↑               │
┌────────────┐        │
│ TCP 头 + 应用数据 │ ← TCP 层
└────────────┘        │
       ↑               │
┌────────────┐        │
│ IP 头 + TCP + 应用 │ ← IP 层
└────────────┘        │
       ↑               │
┌────────────┐        │
│ MAC头+IP+TCP+应用 │ ← 网卡驱动（以太网帧）
└────────────┘        │
       ↑               │
  从网卡接收帧      ←──┘
```

---

## 三、为什么必须从底层开始？

1. **协议栈是分层的，每层都依赖下层的“头部”判断处理逻辑。**

   * 比如 IP 层必须先读取 MAC 帧头，才能确认帧类型是否是 IPv4。
   * TCP 层必须看到 IP 头部，才能知道源/目的 IP 地址和协议号。

2. **每层的“头部”结构和长度都不同，不能跳过处理。**

3. **安全和稳定性考虑**：底层先做校验、过滤、丢弃非法包，避免高层浪费资源。

---

## 四、Linux 中处理流程（内核网络协议栈）

在 Linux 内核中，流程如下：

```text
[1] 网卡硬件收到帧（DMA 到内存）
[2] 网卡驱动调用 NAPI（软中断） → 收包函数
[3] skb（socket buffer）结构封装帧数据
[4] 进入协议栈 → 从 MAC 层开始解封装
[5] IP 层 → TCP/UDP 层 → Socket 层 → 用户进程
```

---

## 五、总结重点

| 问题              | 解答                              |
| --------------- | ------------------------------- |
| 为什么是从底层往上处理？    | 因为协议栈是**逐层封装**的，必须逐层解封装         |
| 和封装有关系吗？        | 完全有关，封装决定了解封装顺序                 |
| 哪些层参与封装/解封装？    | MAC → IP → TCP/UDP → 应用（如 HTTP） |
| 是网卡处理完就交给用户程序吗？ | 不是，中间要经过内核的多层协议处理               |

---