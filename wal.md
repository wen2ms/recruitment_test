## 精确版流程示意：

### ✔ 正常流程（无异常）：

1. 写请求到达。
2. 生成 Undo Log 和 Redo Log。
3. 先把日志写入 WAL。
4. 修改内存缓冲池中的数据页，产生脏页。
5. 客户端发出 `COMMIT`。
6. Redo Log 标记已提交。
7. 脏页异步刷盘（不一定立即）。
8. 事务结束，Undo Log 作废或被清理。

---

### ✔ 异常或手动 Rollback 流程：

1. 写请求到达。
2. 生成 Undo Log 和 Redo Log。
3. 先把日志写入 WAL。
4. 修改内存缓冲池中的数据页，产生脏页。
5. **事务中途出错或客户端发出 `ROLLBACK`。**
6. 数据库利用 Undo Log，将缓冲池中的数据页恢复到修改前的状态。
7. 相关 Undo Log 作废或被清理。
8. 事务结束，相当于操作“未发生”。

---

## 补充重点：

* **脏页的修改是内存级别的，Rollback 期间直接基于内存脏页撤销变更**，不需要先刷回磁盘再恢复。
* 如果脏页还没刷盘，Rollback 只影响内存数据。
* 如果脏页已经部分刷盘，WAL+Undo Log 机制确保即使系统崩溃，恢复过程也能统一回滚到事务前的状态。

---

## 你可以理解为：

| 场景        | 何时 Rollback         | 怎么 Rollback         |
| --------- | ------------------- | ------------------- |
| **事务未提交** | 事务中出现异常、客户端主动请求     | 用 Undo Log 撤销内存变更   |
| **宕机恢复**  | 系统重启，检测到未完成事务       | 用 Undo Log 撤销磁盘上的变更 |
| **事务已提交** | 不允许 Rollback（必须持久化） | 已提交后只能靠 Redo Log 恢复 |

---

## 最后总结：

✅ Rollback 发生在事务提交前。
✅ Rollback 基于 Undo Log，直接恢复内存数据页。
✅ 如果需要，系统重启时也会利用 Undo Log 做恢复。
