## 协程（Coroutine）

* **定义**：一种用户态的轻量级线程，也称为“协作式线程”或“微线程”。
* **特点**：

  * 运行在单线程内，由程序自己控制调度（非抢占式）。
  * 切换时不需要内核参与，切换开销非常小（保存/恢复部分寄存器和栈上下文）。
  * 适合处理大量轻量任务，如异步IO、并发协作任务。
  * C++20 引入了对协程的标准支持（`co_await`、`co_yield`、`co_return`）。
* **示例**：异步网络请求库用协程来简化代码结构和性能。

---

## 🧩 三者对比表

| 特性      | 进程             | 线程            | 协程             |
| ------- | -------------- | ------------- | -------------- |
| 资源占用    | 多（独立地址空间和资源）   | 较少（共享进程资源）    | 很少（用户态，栈较小）    |
| 上下文切换开销 | 高（涉及内核切换和内存切换） | 中（内核调度，保存寄存器） | 低（用户态切换，无内核干预） |
| 调度方式    | 操作系统抢占式调度      | 操作系统抢占式调度     | 程序员控制协作式调度     |
| 通信方式    | 复杂（IPC）        | 简单（共享内存）      | 简单（函数调用和状态传递）  |
| 编程复杂度   | 高              | 较高（同步、锁等问题）   | 较低（顺序风格写异步代码）  |
| 适用场景    | 资源隔离，稳定性要求高    | 多核并行，响应性要求高   | 大量并发，异步IO处理    |

---

## 简单示意：

* **进程**像一个独立的“工厂”，有自己的车间和员工（资源）。
* **线程**像工厂里的工人，共享车间资源，但每人有自己的工作区（栈）。
* **协程**像工人中的“兼职”，同一个工人分时段干不同活，自己决定什么时候暂停换活，切换迅速。

---

## C++ 代码中

* **线程**：用 `std::thread` 创建，操作系统调度。
* **协程**（C++20+）：

```cpp
#include <coroutine>
#include <iostream>

struct Task {
    struct promise_type {
        Task get_return_object() { return {}; }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() {}
    };
};

Task foo() {
    std::cout << "Before co_await\n";
    co_await std::suspend_always{};
    std::cout << "After co_await\n";
}

int main() {
    auto task = foo();
    // 这里协程挂起，后续调度由程序控制
}
```
