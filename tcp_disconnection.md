从**网络资源利用的角度**来看，TCP 连接中一方直接挂掉（如客户端断电、断网或进程崩溃）而未正常关闭连接，会产生以下**资源浪费和影响**：

---

## ✅ 一、连接资源长时间占用

### 服务端视角：

* TCP 不知道对方是否掉线，会继续**占用 socket 文件描述符（FD）**。
* 会保留该连接的内核状态，包括：

  * TCP 状态控制块（TCB）
  * 接收/发送缓冲区
  * 重传定时器

📌 **影响**：

* 如果并发连接较多，这些“死连接”会占用宝贵的文件描述符和内核内存；
* 可能导致**FD 耗尽**（`EMFILE`）；
* 应用层可能因资源泄露而无法接受新的连接。

---

## ✅ 二、重传引发额外网络负载

* 服务端会不断重传之前发送失败的数据包；
* 这些重传数据包在网络中占用带宽，但不会被任何主机处理；
* 如果连接数非常大，可能会造成**链路拥塞**、**延迟升高**，尤其是在高并发系统中。

---

## ✅ 三、KeepAlive 探测延迟释放资源

* 如果启用了 TCP KeepAlive，内核会在较长时间（默认 2 小时）后才尝试探测对方是否还在线；
* 即使对方已死，这段时间内连接资源仍被白白占用；
* KeepAlive 机制设计初衷是稳妥可靠，但在此类场景中处理**不够及时**。

---

## ✅ 四、可能影响应用逻辑或引起假象

* 应用层认为连接仍然活跃，尝试继续交互；
* 尝试发送数据的 `send()` 可能暂时不报错（数据先缓存），延迟问题暴露；
* 会导致**请求堆积、状态错误、响应阻塞**等问题。

---

## ✅ 解决建议

| 策略               | 描述                                              |
| ---------------- | ----------------------------------------------- |
| 开启 TCP KeepAlive | 定时探测对端是否还在线，及时释放死连接                             |
| 设置 socket 超时     | `setsockopt()` 设置 `SO_RCVTIMEO` 和 `SO_SNDTIMEO` |
| 应用层心跳            | 客户端/服务端定时发送心跳包，发现掉线主动清理                         |
| 使用更现代协议          | 如 QUIC，支持更快速检测丢失和重连                             |

---

## ✅ 总结

> **一方突然挂掉**如果未处理好，会导致：
>
> * 服务端**资源泄漏**
> * 网络上**无用重传负载**
> * 整体系统**吞吐下降**