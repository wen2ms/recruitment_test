TCP 的\*\*拥塞控制（Congestion Control）\*\*机制用于防止过多的数据注入网络导致拥塞崩溃（即“网络拥塞”）。与 **流量控制（Flow Control）** 不同，它不是调节“接收端能处理多少”，而是调节“网络本身能承载多少”。

---

## ✅ 一、TCP 拥塞控制的四个阶段（经典算法）

| 阶段名称                       | 说明                     |
| -------------------------- | ---------------------- |
| 慢启动（Slow Start）            | 指数级增长窗口，快速探测可用带宽       |
| 拥塞避免（Congestion Avoidance） | 线性增长窗口，稳步提升吞吐能力        |
| 快速重传（Fast Retransmit）      | 避免等超时，收到多次重复 ACK 就重传丢包 |
| 快速恢复（Fast Recovery）        | 不回到最小窗口，而是减半窗口继续传输     |

---

## ✅ 二、核心变量说明

| 变量名        | 含义                                             |
| ---------- | ---------------------------------------------- |
| `cwnd`     | 拥塞窗口（congestion window），表示当前允许发送的数据量           |
| `ssthresh` | 慢启动阈值（slow start threshold），控制从指数增长切换到线性增长的临界值 |
| `rwnd`     | 接收窗口，由接收端控制，是流量控制用的                            |
| 实际发送窗口     | `min(cwnd, rwnd)`，TCP 实际能发的数据受到两个窗口共同限制        |

---

## ✅ 三、详细过程图解（可配图）

### 1. 🌱 **慢启动（Slow Start）**

* 初始 `cwnd = 1 MSS`（一个最大报文段大小）
* 每收到一个 ACK，就让 `cwnd += 1 MSS`
* 每个 RTT，`cwnd` 翻倍（指数增长）

直到：

* `cwnd >= ssthresh`，切换到拥塞避免
* 或发生丢包，进入快速重传/恢复

---

### 2. 📈 **拥塞避免（Congestion Avoidance）**

* `cwnd += 1 MSS` 每 RTT（线性增长）
* 稳定阶段，小心探测带宽极限

---

### 3. ⚠️ **快速重传（Fast Retransmit）**

* 收到 3 个重复 ACK（说明有个中间包丢了），立即重传，不等超时

---

### 4. 🔁 **快速恢复（Fast Recovery）**

* 认为网络“部分拥塞”
* `ssthresh = cwnd / 2`
* `cwnd = ssthresh + 3 * MSS`（跳过拥塞丢失的段）
* 之后进入拥塞避免

---

## ✅ 四、丢包后的处理逻辑总结

| 情况           | 操作                                            |
| ------------ | --------------------------------------------- |
| 超时重传         | `ssthresh = cwnd / 2`，`cwnd = 1 MSS`，回到慢启动    |
| 收到 3 个重复 ACK | 进入快速重传 + 快速恢复，`ssthresh = cwnd / 2`，调整 `cwnd` |

---


## ✅ 1. 什么是 **RTT（Round-Trip Time）**？

**RTT 是往返时延**，指一个数据包从发送端出发，到接收端并返回确认 ACK 所花费的时间。

### ✳ 举例：

1. 客户端发送一个数据包到服务器；
2. 服务器收到后立即回复一个 ACK；
3. 客户端从发送到收到这个 ACK 一共花了 **100ms**，那么：

   ```
   RTT = 100ms
   ```

### ✳ RTT 的作用：

* **影响超时时间（RTO）设置**：TCP 根据 RTT 动态调整重传超时（RTO）；
* **影响吞吐量**：高 RTT 意味着响应慢，影响用户体验。

---

## ✅ 2. 什么是 **MSS（Maximum Segment Size）**？

**MSS 是“最大报文段大小”**，即 **TCP 层一次发送数据的最大大小（不含 TCP/IP 头）**。

### ✳ 默认大小：

* 一般是 `1500（MTU） - 40（TCP/IP 头） = 1460 字节`
* `MTU`（最大传输单元）指的是网络层最大能传的包大小（例如以太网为 1500 字节）

### ✳ MSS 的意义：

* 防止分片：合理设置 MSS 可以让 TCP 报文在网络层不被拆分。
* TCP 握手时会协商双方的 MSS。

---

## ✅ 3. 什么是 **2MSL（两倍最大报文生存时间）**？

**MSL（Maximum Segment Lifetime）是一个 TCP 报文在网络中能存活的最大时间**。

* TCP 的四次挥手中，**主动关闭的一方（一般是客户端）进入 TIME\_WAIT 状态**，并保持 2 倍 MSL 的时间，防止旧的包影响新连接。

### ✳ 为什么是 2MSL？

* 等待时间要保证：

  1. **自己的最后一个 ACK 报文**有时间送达；
  2. 如果对方没收到 ACK，它会重发 FIN，**2MSL 时间足够重发 + 回复 ACK**。

### ✳ 2MSL 是多久？

* 由操作系统决定，常见设置：

  * Linux：MSL = 60s → 2MSL = 120s
  * Windows：MSL = 30s → 2MSL = 60s

---

## ✅ 总结对比表

| 名称   | 全称                           | 含义                     | 典型取值          |
| ---- | ---------------------------- | ---------------------- | ------------- |
| RTT  | Round Trip Time              | 一个数据包的来回时间             | 10ms \~ 数百 ms |
| MSS  | Maximum Segment Size         | 每个 TCP 报文段的数据最大大小（不含头） | 通常是 1460 字节   |
| 2MSL | 2 × Maximum Segment Lifetime | TCP 报文段在网络中允许存活时间的两倍   | 60s \~ 120s   |

---
