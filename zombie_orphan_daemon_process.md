### 1. 僵尸进程（Zombie Process）

**定义：**
子进程已经结束运行（即调用了 `exit()`），但其父进程还未调用 `wait()` 或 `waitpid()` 获取其退出状态。此时子进程的部分信息（如 PID 和退出码）仍保存在内核中，以便父进程读取 —— 这个状态下的子进程叫做**僵尸进程**。

**特征：**

* 进程已经终止，但仍占用一个 PID。
* 状态为 `Z`（在 `ps` 命令输出中可以看到）。
* 不会使用 CPU，但会占用一定内核资源。
* 如果父进程一直不调用 `wait()`，这些僵尸进程就会堆积，最终耗尽系统的 PID 资源。

**解决方式：**

* 父进程应正确处理子进程退出（使用 `wait()` 或注册 `SIGCHLD` 信号处理器）。
* 如果父进程终止，init 进程（PID 1）会接管子进程并回收资源。

---

### 2. 孤儿进程（Orphan Process）

**定义：**
当一个子进程的**父进程意外终止**，而子进程仍在运行，此子进程就变成了**孤儿进程**。

**处理方式：**

* Linux 中的 init（或 systemd）进程会自动“收养”孤儿进程，成为它们的新父进程，并负责回收它们退出后的资源。

**用途：**

* 一些守护进程就是通过“变成孤儿进程”来脱离控制终端的。

---

### 3. 守护进程（Daemon Process）

**定义：**
守护进程是一种在后台运行、独立于控制终端的特殊进程，通常用于执行系统服务，如 `sshd`、`nginx`、`cron` 等。

**特征：**

* 没有控制终端。
* 通常是系统启动时创建，运行周期长。
* 通过 fork 两次的方式使其成为孤儿进程，然后被 init 接管，实现后台运行。

**典型的创建步骤：**

```c
pid_t pid = fork();
if (pid > 0) exit(0);  // 父进程退出，子进程继续
setsid();              // 创建新的会话，脱离控制终端
pid = fork();
if (pid > 0) exit(0);  // 再次 fork，防止重新获得终端
// 后续关闭文件描述符、改变工作目录等
```

**总结：**

| 类型   | 定义                  | 特点                              |
| ---- | ------------------- | ------------------------------- |
| 僵尸进程 | 子进程结束，父进程未 `wait()` | 占用 PID，状态为 `Z`，不可杀死，仅能通过父进程处理消除 |
| 孤儿进程 | 父进程终止，子进程仍运行        | 被 init 接管，不会导致资源泄露              |
| 守护进程 | 脱离终端、后台运行的进程        | 通过双重 fork 创建，常用于后台服务            |



## 🧟‍♂️ 僵尸进程的解决办法

### 🧠 回顾定义：

僵尸进程是**子进程已经退出**，但**父进程没有调用 `wait()` 或 `waitpid()`** 来回收其状态信息，导致它仍在内核中保留一个条目，占用 PID。

### ✅ 解决方法：

#### 方法 1：父进程调用 `wait()` 或 `waitpid()` 等待子进程退出（**最常用**）

```c
pid_t pid = fork();
if (pid == 0) {
    // 子进程
    exit(0);
} else {
    // 父进程
    waitpid(pid, NULL, 0);  // 回收子进程
}
```

#### 方法 2：父进程注册 `SIGCHLD` 信号处理器（**适用于后台子进程**）

```c
#include <signal.h>
#include <sys/wait.h>

void sigchld_handler(int signum) {
    while (waitpid(-1, NULL, WNOHANG) > 0);  // 回收所有已退出的子进程
}

int main() {
    signal(SIGCHLD, sigchld_handler);
    // fork 子进程等逻辑
}
```

#### 方法 3：让子进程的父进程变为 `init`，由 `init` 负责回收（**只适用于不想自己管的子进程**）

* `init` 或 `systemd` 作为 PID 1 会**自动回收**僵尸子进程。
* 方法是让父进程退出，子进程成为孤儿（见下文），这样就不再是你的责任。

---

## 🧒 孤儿进程的解决办法

### 🧠 回顾定义：

孤儿进程是**父进程已经退出**，而子进程仍在运行，此时该子进程由 `init`（PID 1）接管。

### ✅ 是否需要解决？

* **不需要专门解决！** Linux 的 `init` 或 `systemd` 会自动接管孤儿进程，并负责回收它们，**孤儿进程不会造成资源泄露**。
* 所以孤儿进程通常是“**一种中间状态**”，不是错误或 bug。

### ✅ 控制子进程的生命周期的方式：

* **方案 1：父进程退出前 kill 子进程**

  ```c
  kill(child_pid, SIGTERM);
  ```

* **方案 2：使用进程组或会话统一管理子进程（比如守护进程）**

---

## 📌 总结表格

| 问题类型 | 本质           | 是否需要主动解决 | 推荐解决方案                                |
| ---- | ------------ | -------- | ------------------------------------- |
| 僵尸进程 | 父进程未回收已退出子进程 | ✅ 需要     | `wait()` / `waitpid()` / 处理 `SIGCHLD` |
| 孤儿进程 | 子进程父进程提前退出   | ❌ 不需要    | 由 `init`/`systemd` 自动接管，无需担心          |

---
