C++ 的多态（Polymorphism）主要是通过\*\*虚函数（virtual function）+ 虚函数表（vtable）\*\*机制来实现的。下面我们从概念、实现原理、内存结构等几个方面讲解：

---

## 🔷 一、什么是多态？

多态分为两类：

1. **编译时多态（静态多态）**：

   * 通过函数重载（Overload）、模板（Template）等机制实现。
   * 编译期就决定了调用哪个函数。

2. **运行时多态（动态多态）**：

   * 通过继承和虚函数实现。
   * 调用哪个函数要等到运行时才能决定（依赖指针/引用指向的实际对象）。

我们通常所说的 **多态** 指的是 **运行时多态**，通过**基类指针调用子类方法**实现行为变化。

---

## 🧠 二、底层实现机制：vtable（虚函数表）

### 📌 1. 虚函数表（vtable）

* 每个包含虚函数的类，编译器会为它生成一张**虚函数表**，里面存的是指向虚函数的指针。
* 每个对象内部会有一个**指向该表的指针**，叫做 **vptr（虚表指针）**。

### 📌 2. 动态绑定过程

* 当你通过 `Animal*` 指针调用 `speak()` 时：

  * 程序通过 `vptr` 找到 vtable；
  * 从 vtable 中找到 `speak` 对应的函数地址；
  * 跳转到真正的函数执行（此处是 `Dog::speak()`）。

### 📌 3. 内存示意图

```txt
Dog 对象内存布局：

[ vptr ] ----> 指向 Dog 的虚函数表
[ 其他成员变量... ]

Dog 的虚函数表：

[ &Dog::speak ]
```

---

## ⚠️ 四、使用注意事项

| 注意点                | 说明                          |
| ------------------ | --------------------------- |
| 必须使用**指针或引用**      | 多态只在使用基类的指针或引用时有效           |
| 析构函数建议设为 `virtual` | 否则通过基类指针析构子类时会导致资源泄露        |
| 无法在构造函数中多态         | 构造函数中不会调用子类的虚函数（因为对象还未完全构造） |

---

## ✅ 总结一句话：

> C++ 的运行时多态是通过 **虚函数表（vtable）+ 虚表指针（vptr）** 实现的：调用时通过 `vptr` 查表，跳转到正确的函数地址，实现动态绑定。
