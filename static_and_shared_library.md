C++ 中的\*\*静态库（Static Library）**和**动态库（Dynamic Library，也叫共享库，Shared Library）\*\*是两种不同的代码复用方式。它们在编译、链接、运行时的表现和用途都有所不同：

---

### 🔧 一、定义与生成方式

| 项目          | 静态库                     | 动态库                                    |
| ----------- | ----------------------- | -------------------------------------- |
| 后缀（Linux）   | `.a`                    | `.so`                                  |
| 后缀（Windows） | `.lib`                  | `.dll`（+ `.lib` 导入库）                   |
| 链接方式        | 编译时直接将库内容打包进可执行文件       | 运行时加载，程序运行时才链接                         |
| 构建命令示例      | `ar rcs libxxx.a xxx.o` | `g++ -shared -fPIC -o libxxx.so xxx.o` |

---

### 🚀 二、使用方式与运行特点

| 特点      | 静态库         | 动态库                |
| ------- | ----------- | ------------------ |
| 可执行文件大小 | 较大（包含所有库代码） | 较小（不包含库的实现）        |
| 程序运行时   | 不依赖外部库文件    | 依赖 `.so/.dll` 存在   |
| 更新库功能   | 需重新编译程序     | 替换 `.so/.dll` 即可生效 |
| 多个程序共享  | 否（各自打包）     | 是（节省内存、便于更新）       |
| 加载性能    | 加载快，启动快     | 启动时需加载动态库，略慢       |

---

### 🧩 三、适用场景

#### ✅ 静态库适合：

* 单个项目开发，部署简单；
* 不希望用户单独接触库文件；
* 不依赖运行时环境；

#### ✅ 动态库适合：

* 多项目共享同一份库，节省空间；
* 需要热更新、插件机制；
* 系统级组件开发（如 Linux 中的 `.so`）；

---

### 📦 四、示例说明

```bash
# 生成静态库
g++ -c math.cpp        # 编译成目标文件 math.o
ar rcs libmath.a math.o  # 打包成静态库

# 生成动态库
g++ -fPIC -c math.cpp  # 编译成位置无关代码
g++ -shared -o libmath.so math.o  # 生成共享库
```

```cpp
// 链接静态库
g++ main.cpp -L. -lmath -o app

// 链接动态库
g++ main.cpp -L. -lmath -o app
export LD_LIBRARY_PATH=.  # 运行前设置库路径
./app
```

---

### ✅ 总结一句话：

* 静态库：**编译时复制代码进去**，更独立；
* 动态库：**运行时加载，支持共享与更新**，更灵活。
