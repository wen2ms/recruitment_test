文件存储结构就是操作系统将一个文件在磁盘上组织和存储起来的方式，包括文件系统`File System`，块`Block`，元数据`Metadata`。

### 1. 文件存储

一个文件存储主要由三部分组成：文件实际存储的数据内容，磁盘上的若干数据块，还有文件名，文件大小，时间等组成的元数据。用户看到的是文件的数据，而文件实际的物理结构是由存储在磁盘上的若干数据块和一个存放元数据和数据块指针的`inode`组成的。例如我们可以通过`stat(sub_path, &st);`得到文件对应的元数据。

一个目录也是一个文件，例如`/home/docs/file.txt`中，`/home/docs/`是一个目录，它其中有一个对应`file.txt`的目录项，目录项中包含`char name[]`文件名，`unsigned int inode`就是这个文件的`inode`编号，`unsigned char name_len`就是文件名的长度，因此文件名最大是`255 Bytes`。目录是一个存储了文件名和`inode`的表。因此一个小文件也会占用至少一个数据块`4KB`和一个`inode 256B`，和目录中的一个目录项。

### 2. 块存储

#### 2.1 存储格式

块的的存储结构根据文件系统不同而不同，`ext4`中采用直接块+间接块，一个`inode`中包括几个直接块指针和一个或者多个间接块指针，间接块指针指向一个块，这个块中又有指向其他块的直接块指针。而对于`FAT32`，使用了文件分配表保存着每一簇和它对应的下一簇的地址，文件的元数据和起始簇地址是存放在目录项中的，这与`ext4`不一样。

块指针实际上是一个逻辑块号`LBN (Logic Block Number)`，文件系统通过块分配表找到`LBA (Logic Block Address)`，由硬件驱动根据`LBA`控制磁盘控制器，然后磁盘控制器执行磁头读取数据的操作。因此块就是文件系统管理磁盘空间的最小单位，磁盘上的数据是以块来读写分配的。为了方便进行`mmap`映射，块大小和页大小一般相等为`4KB`，但也有`512B`。

#### 2.2 块读取

一个程序调用`read(fd, buf, size)`读取一个文件描述符`fd (file description)`中的数据，CPU首先从用户态陷入内核态，执行`read`系统调用，文件系统根据进程的`fdtable`找到文件的`inode`，`inode`中保存了数据块指针，指针指向磁盘上的数据块地址，然后由驱动到磁盘控制器读取到磁盘上的块数据，然后重新向后一步步封装，最后由内核将数据拷贝到用户空间缓冲区，由`read`返回。

#### 2.3 块设备与字符设备
块设备是以数据块为单位访问的外设，比如硬盘，它可以随机访问。字符设备是以字节流为单位访问的外设，比如键盘，声卡等，它不能随机访问，只能顺序访问。

### 3. 文件描述符

`fd`实际上是`I/O`对象对应的一个整数，就是操作系统中文件的句柄，包括文件，`socket`，设备，标准输入输出，管道等。例如程序调用`int fd = open("/home/docs/file.txt", O_RDONLY);`内核会先从`/`目录项中找到`/home`的`inode`，然后从`/home`目录项中找到`/home/docs`的`inode`，最终再读取`file.txt`的`inode`，然后将这个`inode`缓存到内存中，进程的`fdtable`中会新建一个`struct file`结构体。

`file`结构体包含了当前文件的读写偏移`offset`，文件的访问权限，以及指向`inode`的指针，而进程的`fdtable`中的`fd`对应的项就是这个`file`结构体。例如`lseek(fd, 0, SEEK_SET);`就是读写`fd`对应的`file.f_pos`的文件偏移量。

`lfd_ = socket(AF_INET, SOCK_STREAM, 0)`可以得到一个`fd`。`0, 1, 2`分别对应`stdin, stdout, stderr`。`inode`的数量是有限的即使还有磁盘空间如果`inode`用尽，也无法创建新文件了，例如文件系统根据每`16KB`的数据块分配一个`inode`，同时有进程正在通过`fd`打开文件，那即使通过文件名删除了文件也只是删除了它在目录中的目录项，`inode`还是在，磁盘空间也没有被释放。

### 4. 链接

软链接和硬链接是文件应用的方式。软链接也叫符号链接，实际上就是一个指向原始路径的特殊文件，当源文件删除后，这个链接就失效了，它不依赖于`inode`所以可以跨磁盘分区，跨文件系统。而硬链接实际上就是指向`inode`，它和源文件共享数据块和`inode`，删除了一个硬链接，只要其他文件名还在，数据就不会丢失，类似于引用计数。但也因此不支持跨磁盘分区创建。

### 5. 分区

一个挂载点对应一个目录，它将磁盘分区，逻辑卷或者虚拟文件系统绑定到这个目录上，常见的分区包括`/home`用户分区，`/boot`启动分区等。一般情况下一个分区就对应一个文件系统，而`LVM (Logical Volume Manager)`中一个逻辑卷`LV (Logical Volume)`包含了多个物理卷`PV (Physical Volume)`，将多个物理分区看做一个分区来建立统一的文件系统。

常见的目录包括`/var`可变数据目录用来存储日志，`/usr`用户程序目录用来存储用户工具和库，`/swap`交换分区作为虚拟内存使用，但它没有文件系统，不依赖于文件系统访问。`/proc`是内核提供的虚拟文件系统，它动态的将各种内核信息和状态映射成文件。

### 6. 系统调用与中断

用户程序想要访问硬件就需要CPU由用户态转化为内核态来请求内核服务，包括系统调用例如：

```cpp
int count = epoll_wait(epfd_, events_, kMaxNode, timeout * 1000);
int count = poll(fds_, maxfd_ + 1, timeout * 1000);
int count = select(kMaxSize, &rdtmp, &wrtmp, NULL, &val); 
```

#### 6.1 IO多路复用

`epoll, select, poll`都IO多路复用的技术，用来处理多个`fd`的IO事件。

它们的区别在于`select`同时支持的最大监听的`fd`数量是有限的`1024`，同时它是通过`bitset`来进行管理的，每次调用时操作系统会将`fd_set`从用户空间拷贝到内核空间，每次调用`select`都需要扫描所有的文件描述符，即使有很多没有事件触发。

而`poll`采用了`struct pollfd*`来进行管理，可监听的`fd`更多，但每次调用`poll`也需要进行从用户空间到内核空间的拷贝。

`epoll`只是在`epoll_ctl`时在内核空间注册一次，之后调用`epoll_wait`都不需要拷贝，而是通过回调机制返回有事件触发的`fd`，同时`epoll`是有水平触发`LT (Level-Triggered)`和边沿触发模式`ET (Edge-Triggered)`。`ET`模式下，内核只会在`fd`在事件触发的一瞬间发送一次通知，例如`EPOLLIN, EPOLLOUT`，即使程序还没有处理完数据，也不会再发送通知了。因此程序必须循环的进行`read/write`，直到返回`errno == EAGAIN`表示数据处理完了，但是此时程序还是会继续在循环中调用`read/write`，导致程序卡住，甚至接收不到一下次通知，因此`ET`模式下的`fd`必须是非阻塞模式：

```cpp
int flag = fcntl(cfd, F_GETFL);
flag |= O_NONBLOCK;
fcntl(cfd, F_SETFL, flag);
```

#### 6.2 中断

软中断是由程序触发的中断，例如通过系统调用接口来调用系统服务`syscall`或者通过信号模拟中断，还有程序中导致的异常，例如缺页异常`page fault`或除零异常。

硬中断是硬件设备触发的中断，例如设备的输入输出，网络IO，磁盘读写完成，时针中断，它是由设备产生的，比软中断优先级更高。

CPU监测到中断立即中断当前程序，从用户态转换为内核态，转去执行中断处理程序。例如当`std::cout << "foo" << '\n';`时，程序触发系统调用`write`，此时是软中断，CPU陷入内核态，将数据从用户空间写入内核缓冲区，`DMA (Direct Memory Access)`可以直接访问内存中内核缓冲区的数据，`DMA`发送数据给`tty`，输出完成后就会触发硬中断，通知内核完成传输。

网卡收到网络包，然后通过`DMA`发送到内核缓冲区，并触发一个硬中断，内核根据协议逐层解包，然后将数据放回到用户空间的`socket`缓冲区，然后程序通过`recv`读取数据。