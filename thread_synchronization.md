çº¿ç¨‹ç«äº‰ï¼ˆRace Conditionï¼‰æ˜¯å¤šä¸ªçº¿ç¨‹åœ¨è®¿é—®**å…±äº«èµ„æº**æ—¶ï¼Œç”±äºæ‰§è¡Œé¡ºåºä¸ç¡®å®šï¼Œå¯èƒ½å¯¼è‡´ç¨‹åºè¡Œä¸ºå¼‚å¸¸æˆ–ç»“æœé”™è¯¯çš„é—®é¢˜ã€‚ä¸ºäº†å¤„ç†çº¿ç¨‹ç«äº‰ï¼Œå¿…é¡»é‡‡å–**åŒæ­¥æœºåˆ¶**æ¥ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚ä¸‹é¢æ˜¯å‡ ç§å¸¸è§çš„å¤„ç†æ–¹æ³•ï¼š

---

## ğŸ”’ 1. äº’æ–¥é”ï¼ˆMutexï¼‰

ä½¿ç”¨äº’æ–¥é”ï¼ˆå¦‚ `pthread_mutex_t`ã€C++ `std::mutex`ï¼‰ä¿æŠ¤å…±äº«èµ„æºã€‚

```cpp
std::mutex mtx;

void threadFunc() {
    mtx.lock();
    // è®¿é—®å…±äº«èµ„æº
    mtx.unlock();
}
```

æ¨èä½¿ç”¨ `std::lock_guard` è‡ªåŠ¨é‡Šæ”¾é”ï¼Œé˜²æ­¢å¿˜è®° unlockï¼š

```cpp
void threadFunc() {
    std::lock_guard<std::mutex> lock(mtx);
    // å®‰å…¨è®¿é—®å…±äº«èµ„æº
}
```

---

## â³ 2. è¯»å†™é”ï¼ˆRead-Write Lockï¼‰

å¦‚æœè¯»å¤šå†™å°‘ï¼Œå¯ä»¥ä½¿ç”¨è¯»å†™é”ï¼ˆå¦‚ `pthread_rwlock_t` æˆ– `std::shared_mutex`ï¼ŒC++17 èµ·ï¼‰ã€‚

```cpp
std::shared_mutex rwLock;

void reader() {
    std::shared_lock lock(rwLock);
    // åªè¯»å…±äº«èµ„æº
}

void writer() {
    std::unique_lock lock(rwLock);
    // ä¿®æ”¹å…±äº«èµ„æº
}
```

---

## âš™ï¸ 3. åŸå­æ“ä½œï¼ˆAtomicï¼‰

ä½¿ç”¨ `std::atomic<T>` ä¿è¯åŸºæœ¬æ•°æ®ç±»å‹çš„çº¿ç¨‹å®‰å…¨ï¼Œä¸éœ€è¦åŠ é”ã€‚

```cpp
std::atomic<int> counter(0);

void increment() {
    counter++;
}
```

é€‚åˆç®€å•è®¡æ•°æˆ–æ ‡å¿—ä½ã€‚

---

## ğŸ§© 4. æ¡ä»¶å˜é‡ï¼ˆCondition Variableï¼‰

ç”¨äºçº¿ç¨‹ä¹‹é—´çš„åè°ƒï¼Œä¾‹å¦‚ç­‰å¾…æŸä¸ªæ¡ä»¶æ»¡è¶³åå†ç»§ç»­æ‰§è¡Œã€‚

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void waitThread() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; });
    // æ¡ä»¶æ»¡è¶³åæ‰§è¡Œ
}
```

---

## ğŸ§  æ³¨æ„äº‹é¡¹

* **ä¸è¦åœ¨æŒæœ‰é”æ—¶è°ƒç”¨å¯èƒ½é˜»å¡çš„å‡½æ•°**ï¼Œå¦åˆ™å®¹æ˜“æ­»é”ã€‚
* **å°½é‡ç¼©å°é”çš„ç²’åº¦**ï¼Œå³åªåœ¨éœ€è¦ä¿æŠ¤çš„ä»£ç æ®µåŠ é”ã€‚
* **é¿å…å¤šä¸ªé”äº¤å‰æŒæœ‰**ï¼Œé˜²æ­¢æ­»é”ã€‚
* å¦‚æœä½ åœ¨ç”¨ `pthread`ï¼ˆå¦‚ä½ ä¹‹å‰æåˆ°çš„ï¼‰ï¼Œå¯ä»¥ä½¿ç”¨ `pthread_mutex_lock/unlock`ã€‚

---
