C++11 引入了三种智能指针，用于更安全和高效地管理动态内存，避免手动 `delete` 导致的内存泄漏和悬空指针问题。它们分别是：

---

### 1. `std::unique_ptr` —— 独占式智能指针

#### **特点**：

* **独占所有权**：同一时间只能有一个 `unique_ptr` 指向某个对象。
* **不能拷贝**，只能**移动**（可使用 `std::move` 转移所有权）。

#### **适用场景**：

适用于需要**唯一拥有对象**的情况，比如资源管理类或函数内部资源。

#### **示例**：

```cpp
std::unique_ptr<int> p1 = std::make_unique<int>(10); // 创建并拥有
std::unique_ptr<int> p2 = std::move(p1);             // 转移所有权
```

---

### 2. `std::shared_ptr` —— 引用计数智能指针

#### **特点**：

* **多个指针可以共享对象的所有权**。
* 每个 `shared_ptr` 内部维护一个**引用计数**，当计数为 0 时自动释放内存。

#### **适用场景**：

适用于多个对象**共享资源**的情况，如图节点、缓存池等。

#### **示例**：

```cpp
std::shared_ptr<int> p1 = std::make_shared<int>(20);
std::shared_ptr<int> p2 = p1; // 引用计数+1
```

---

### 3. `std::weak_ptr` —— 弱引用智能指针

#### **特点**：

* **不控制对象生命周期**，不会增加引用计数。
* 必须通过 `lock()` 显式转换为 `shared_ptr` 使用。

#### **用途**：

用于**解决 shared\_ptr 循环引用**的问题，比如双向链表、父子节点结构。

#### **示例**：

```cpp
std::shared_ptr<int> sp = std::make_shared<int>(30);
std::weak_ptr<int> wp = sp;  // 不增加引用计数

if (auto tmp = wp.lock()) {
    std::cout << *tmp << std::endl; // 安全使用
}
```

---

### 总结对比表：

| 指针类型         | 所有权 | 引用计数 | 是否可拷贝 | 用途           |
| ------------ | --- | ---- | ----- | ------------ |
| `unique_ptr` | 独占  | 否    | 否     | 单一拥有者，资源管理   |
| `shared_ptr` | 共享  | 是    | 是     | 多个共享者，常见智能指针 |
| `weak_ptr`   | 弱引用 | 否    | 是     | 避免循环引用       |

---