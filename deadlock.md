死锁是多线程/多进程系统中一种常见的并发问题，指的是**多个线程因相互等待对方持有的资源而无限期阻塞，永远无法继续执行**的现象。

---

## 一、死锁的四个必要条件（**同时满足才会产生死锁**）：

这是著名的 **Coffman 条件**，包括：

### 1. **互斥条件（Mutual Exclusion）**

资源一次只能被一个线程占用。
例如：mutex 只能被一个线程加锁。

### 2. **占有且等待条件（Hold and Wait）**

一个线程已经持有一个资源，又去请求另一个被别的线程占用的资源，而不释放已有的资源。

### 3. **不剥夺条件（No Preemption）**

已获得的资源不能被强制剥夺，只能由占有者主动释放。

### 4. **循环等待条件（Circular Wait）**

存在一个**线程等待环**，比如线程 A 等线程 B 的资源，线程 B 等线程 C 的资源，线程 C 又等线程 A 的资源。

---

## 二、图示说明

假设：

* 线程 A 拿着锁 L1，想拿锁 L2；
* 线程 B 拿着锁 L2，想拿锁 L1；

则：

```
线程 A: 等待 L2 ←———
       拿着 L1         ↑
                      |
线程 B: 等待 L1 ——→ 拿着 L2
```

形成**循环等待**，导致死锁。

---

## 三、如何避免死锁？

### 常用策略：

1. **破坏循环等待条件**

   * 所有线程按**统一顺序加锁**，避免循环等待。
   * 示例：总是先加 L1，再加 L2，不管线程是谁。

2. **使用 `try_lock()`**

   * 如果无法获得锁，立即返回，不等待。

3. **设置超时机制**

   * 如果超过时间未获取资源，主动放弃，避免永久等待。

4. **避免资源长期持有**

   * 使用 `lock_guard` 等 RAII 技术，作用域结束自动释放锁。

---
