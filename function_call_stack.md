## 🧠 一、栈的基本概念

* **栈（Stack）** 是一种\*\*后进先出（LIFO）\*\*的数据结构。
* 在程序运行过程中，每次函数调用都会创建一个**栈帧（Stack Frame）**，用于保存：

  * 实参（参数）
  * 返回地址
  * 局部变量
  * 寄存器保存现场（保存/恢复寄存器）

> 栈位于内存的高地址区域，一般从高地址向低地址增长（向下增长）。

---

## 🧭 二、函数调用过程中的栈变化（以 x86 架构为例）

假设有如下代码：

```c
int add(int a, int b) {
    int c = a + b;
    return c;
}

int main() {
    int result = add(3, 4);
}
```

### 栈的变化过程简要如下：

1. **`main` 调用 `add(3, 4)`：**

   * 参数从右往左依次入栈：先 push `4`，再 push `3`
   * 调用指令 `call add`：将返回地址压栈
   * 控制权跳转到 `add`

2. **进入 `add` 函数：**

   * 创建栈帧（通过 `push ebp` 和 `mov ebp, esp` 建立栈帧基址）
   * 为局部变量 `c` 分配栈空间（`sub esp, n`）

3. **`add` 函数执行完毕返回：**

   * 返回值一般通过寄存器 `eax` 返回
   * 恢复栈帧并清理参数（由 caller 或 callee 决定）
   * `ret` 指令弹出返回地址并跳回 `main`

---

## 📐 三、典型函数栈帧结构（x86）

```
高地址
│
│  参数2（b） ← esp + 8
│  参数1（a） ← esp + 4
│  返回地址   ← esp
│  旧的 ebp   ← ebp
│  局部变量 c ← ebp - 4
│
低地址 ← esp
```

---

## 🧩 四、返回值的位置

| 类型                       | 返回方式                      |
| ------------------------ | ------------------------- |
| `int`, `char`, `pointer` | 返回值保存在 `eax` 或 `rax` 寄存器中 |
| 结构体（小）                   | 也可能通过寄存器                  |
| 结构体（大）                   | 返回地址作为隐藏参数压栈或寄存器传递        |

---

## 🧾 五、常见面试/考点总结

| 内容          | 说明                   |
| ----------- | -------------------- |
| 栈增长方向       | 向下（从高地址向低地址）         |
| 参数压栈顺序（x86） | 从右到左                 |
| 调用约定作用      | 决定参数如何传递，谁清理栈        |
| 栈帧的作用       | 保存函数调用的上下文环境         |
| 局部变量分配位置    | 栈帧中，ebp 往下（低地址）偏移    |
| 静态变量是否入栈    | 否，静态区                |
| 返回值如何传递     | 小型值通过寄存器，大型结构可能用隐藏指针 |

---

### 二、函数的两个形参是怎么入栈的？

函数调用时，形参的传递方式一般遵循 **调用约定（calling convention）**，其中**入栈与否**取决于编译器、平台、CPU 架构等，以下是基于典型的 x86 和 x86\_64 平台的说明：

#### ✅ x86（32 位）平台（cdecl、stdcall 等调用约定）

* 所有参数**从右往左**依次**压栈**
* 栈由高地址向低地址增长
* 示例函数：

```c
void func(int a, int b);
func(1, 2);
```

* 执行过程（简化）：

  ```
  push 2   ; b 入栈
  push 1   ; a 入栈
  call func
  ```

#### ✅ x86\_64（64 位）平台（System V AMD64 ABI）

* 前 6 个整数/指针类型参数通过**寄存器传递**（如 RDI, RSI, RDX, RCX, R8, R9）
* 超过的参数才会入栈
* 示例：

```c
void func(int a, int b);
```

* 参数传递过程：

  * `a` → RDI
  * `b` → RSI

因此在 64 位系统中，**并不是所有形参都入栈**，除非参数很多或某些特殊类型。

---