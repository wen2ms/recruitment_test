在操作系统中，“**内核态（Kernel Mode）**”和“**用户态（User Mode）**”是两种处理器运行权限级别，它们的切换是操作系统设计的核心之一。

---

## 一、什么是用户态和内核态？

| 模式  | 权限 | 运行代码                     | 能否访问硬件/内存管理  |
| --- | -- | ------------------------ | ------------ |
| 用户态 | 低  | 用户程序（如你写的 C++）           | 否，只能通过系统调用   |
| 内核态 | 高  | 操作系统核心部分（如 Linux kernel） | 是，能直接操作硬件和内存 |

---

## 二、用户态和内核态的切换时机（**常见三种情况**）

### 1. **系统调用（System Call）** —— 主动切换

用户程序**主动请求内核服务**（如读文件、分配内存、创建线程等）时，会通过系统调用从用户态切换到内核态。

#### 示例：

```cpp
read(fd, buf, size);  // 用户态 → 内核态
```

#### 实现方式：

* 底层通过 `syscall` 指令（x86\_64）或 `int 0x80`（老系统）陷入内核。
* CPU 切换为内核栈，进入系统调用处理函数。

---

### 2. **中断（Interrupt）** —— 被动切换

当硬件事件（如键盘输入、网卡收到数据）发生时，CPU 会**中断当前用户程序**，进入内核态响应中断。

#### 示例：

* 键盘输入
* 硬盘读写完成
* 网络接收数据包

#### 实现方式：

* CPU 收到中断信号后，自动保存现场，切换到内核态执行中断处理程序。

---

### 3. **异常（Exception）** —— 异常切换

程序运行过程中发生**错误**（如除以 0、访问非法内存等），操作系统需要介入处理。

#### 示例：

```cpp
int a = 1 / 0;        // 除零异常
int* p = nullptr;
*p = 42;              // 空指针访问异常
```

#### 实现方式：

* CPU 检测到异常 → 切换到内核态 → 调用异常处理函数

---

## 三、切换流程简图

```
[用户态] 
   |
   | (系统调用/syscall)
   v
[内核态]（执行内核代码）
   |
   | (返回用户空间)
   v
[用户态]
```

---

## 四、切换成本

从用户态到内核态涉及：

* CPU 权限级别切换（用户态 Ring3 → 内核态 Ring0）
* 保存和恢复上下文（寄存器、堆栈等）
* 切换栈指针（内核有独立栈）

因此，**频繁切换会带来性能损耗**，这也是很多高性能编程（如系统调用优化、零拷贝）需要考虑的因素。

---

## 五、总结表

| 切换方式 | 示例函数 / 触发点         | 用户态 → 内核态？ | 内核态 → 用户态？ |
| ---- | ------------------ | ---------- | ---------- |
| 系统调用 | `read()`、`write()` | 是          | 是          |
| 中断   | 键盘输入、网卡收包          | 是          | 是（中断结束）    |
| 异常   | 除 0、段错误、访问越界       | 是          | 可能终止或恢复    |

---
