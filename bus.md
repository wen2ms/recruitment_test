总线是CPU和内存或外设之间传输数据，地址信号和控制信号的共享通路。根据功能划分，可以分为数据总线，地址总线和控制总线。

## 1 地址总线

地址总线是CPU指定内存中具体地址的通路。

CPU单向的向内存或外设发出地址信号。它决定了CPU可以访问多少内存地址，例如：如果地址总线是n位，那么可寻址空间就是$2^n$个地址，每个地址对应一个字节，32位地址总线对应的可寻址空间就是$2^{32}\text{B} = 4\text{GB}$，64位地址总线对应的可寻址空间就是$2^{64}\text{B} = 16\text{EB}$。

## 2 数据总线

数据总线是CPU双向和内存或外设传输数据的通路。

CPU读操作就是数据由外部到CPU，写操作就是由CPU到内存或外设。数据总线决定了一次能传输多少位数据（数据宽度），例如64位数据总线一次性能传输$2^{64}\text{位} = 8\text{字节}$数据。

## 3 访存

### 3.1 分配变量到虚拟空间

#### 3.1.1 预处理

预处理器会展开头文件，并删除注释，替换宏，并进行条件编译`#ifdef #define #endif`和预处理指令的处理`#pragma once #pragma pack`，宏判断的条件编译和预处理指令的区别是宏判断中宏名必须正确且唯一，需要进入头文件内部判断，而使用`#pragma once`预处理器会记录文件的路径，不会再次进入头文件。大部分现代编译器已经完全支持`#pragma once`。

#### 3.1.2编译

在编译期，编译器会将不同变量放到不同的段`segment`中，生成符号表，所有变量都只有符号名`symbol`，没有虚拟地址。

全局和静态变量只有相对段起始地址的偏移，而栈上的局部变量只有相对栈帧的偏移，内存对齐也是在这里确定的，堆上的变量只有符号名，但是指向堆对象的指针变量是知道它的偏移地址的。

例如`int* ptr= new int(3)`，ptr会在编译阶段有偏移，在链接阶段被确定虚拟地址，但是`new int(3)`在运行时才会分配一个虚拟地址空间。

|            变量类型            |   段/区   | 是否存入磁盘 | 加载到内存中是否可写 |
| :----------------------------: | :-----: | :------: | :-------: |
| 全局变量，静态变量（已初始化） | `.data` |  :white_check_mark:初始值已经保存到`.data`段中，初始值存储在了`ELF`文件中  | :white_check_mark: |
| 全局变量，静态变量（未初始化） | `.bss` |  :x:占位，没有实际值，不占用`ELF`文件空间  | :white_check_mark:运行时初始化为0 |
| 常量，字面量 | `.rodata` |  :white_check_mark:  | :x: |
| 局部非静态变量 | `stack`区 |  :x:编译时分配了在栈帧中的偏移  | :white_check_mark:没有固定的虚拟地址，只有相对栈帧的偏移，运行时调用函数，栈空间在栈帧中分配，结束后释放。初始化通过指令赋值。 |
| 动态分配的变量 | `heap`区 | :x:运行时动态分配 | :white_check_mark:虚拟地址是由运行时由内存分配器分配，每次可能不一样。 |
| 函数定义 | `.text` |  :white_check_mark:记录在`.text`段中的偏移  | :x:只读+执行（RX） |

#### 3.1.3 链接

将多个目标文件`.o`的同类段合并，形成一个可执行文件的段布局，每个段被赋予一个虚拟地址，会在`ELF (Excutable and Linkable Format)`文件中会定义

```sh
.text=0x400000
.rodata=0x600000
.data=0x601000
.bss=0x602000
```

也就是在链接后这个虚拟地址就已经写死了，目标文件中占位的符号名就被实际的虚拟地址替换了。

#### 3.1.4 执行

程序加载会从`ELF`文件中读取`.text`的机器码，`.rodata`的常量和`.data`的初始值，`.bss`只分配虚拟页，值全部清零。运行时将段映射到进程的虚拟地址空间，最后CPU只会执行`.text`段中的代码（机器码），数据存储在其他段中。

- 段是逻辑划分，可以看出它是由编译器和链接器决定的。而页是操作系统管理内存的最小单位，它是由操作系统和`MMU (Memory Management Unit)`管理的。
- 段通常不是页的整数倍，所以加载的时候段会按页对齐，一个段会横跨多个页。例如`.text`段大小是10KB，那么加载的时候需要3页（12KB），`.rodata`紧跟`.text`段，它会和`.text`段共用一页。
- 一个页只有一个权限组合，如果`.text`和`.rodata`在同一页，那么就按照最宽松权限`RX`。
- `ELF`文件中没有`heap`和`stack`，它们是运行时由操作系统分配的。

##### 函数调用栈

每次函数调用都会创建一个栈帧来保存实参，返回地址，局部变量，在`x86`中首先将实参从右向左依次入栈，这里的栈帧是原栈帧，也就是调用者的栈帧，然后再将返回地址，也就是原栈帧的基址入栈，进入函数中首先创建新栈帧，得到新栈帧基址，并为函数内的局部变量分配空间，再访问形参时，实际上就是通过新栈帧基址+偏移找到实参的，函数执行完成后由寄存器返回，并清理栈帧，从返回地址返回。函数调用栈的增长方向是由高地址向低地址入栈。

栈与堆区的区别在栈大小和布局是由编译器确定，操作系统在运行时分配给每个线程栈空间，内存自动销毁，而堆需要程序手动管理，访问速度上栈因为只需要通过寄存器保存栈顶指针，速度更快，同时操作系统对栈区空间申请有限制而堆区基本只受限于内存大小。

#### 3.1.5 库

静态库`Static Library`和动态库`Shared Library`都属于`ELF`文件，静态库`.a`在编译完成后包含了所有源程序代码，实际它是一个归档文件，里面包含了多个目标文件`.o`，每个`.o`文件都是`ELF`文件，等待链接可执行文件时统一链接。而动态库`.so`本身就是一个`ELF`文件，在运行时动态链接器会加载对应的符号加载进内存。

因此静态库文件较大，但运行时很快，更新库的内容就需要重新编译整个代码，多个程序无法共享。而动态库文件小，但运行时需要链接，速度慢，不过更新时只需要替换库文件即可，一个动态库可以被多个程序共享。

### 3.2 虚拟地址

#### 3.2.1 虚拟地址映射

首先CPU得到机器码中变量对应的虚拟内存地址`VA (Vritual Address)`，每一个进程都有独立的虚拟地址空间，然后在CPU的`MMU`中将虚拟地址分为虚拟页号`VPN`和页内偏移`offset`。

再查询页表之前会先查询`TLB (Translation Lookaside Buffer)`，`TLB`存储了最近访问的`VPN`到`PFN`的映射。如果命中直接得到`PFN`，否则需要开始查询页表。

现代操作系统使用了**多级页表**来节省内存，而页表由操作系统为每一个进程维护的，例如使用两级页表，一级索引指向的是页目录，二级索引指向了页表项`PTE`，通过一级索引找到二级页表的物理首地址，然后根据二级页表最终找到虚拟页号对应的物理页框号`PFN`，同时更新`TLB`，最后用`PFN`拼接`offset`得到物理内存地址`PA (Physical Address)`。

一个页和页框的大小通常是$2^{12}\text{B} = 4\text{KB}$，那么虚拟地址的低12位就是`offset`，剩余的高位就是虚拟页号`VPN`，例如一个32位的虚拟地址`VA = 0x12345678`，那么`VPN = 0x12345, offset = 0x678`，如果使用两级页表，那么就会将`VPN`拆成两部分一级索引（10位）和二级索引（10位），`index1 = 0001001000 = 0x048, index2 = 1101000101 = 0x345`，每级页表包含$2^{10} = 1024$条记录，每条记录占4B。假设二级页表是：

| VPN (index2) | PFN     |
| :----------: | ------- |
|    0x345     | 0xABCDE |

那么最后得到`PA = (0xABCDE << 12) | 0x678 = 0xABDCE678`。

- 如果使用单级页表，32位虚拟地址空间，每个页大小是4KB，那么共有$2^{32}/2^{12} = 2^{20}\text{页}$，每个页表项如果是4B，那么一个进程的单个页表大小就是$4 \times 2^{20} = 4\text{MB}$。
- 如果使用多级页表，我们计算的是这个进程用了多少空间，例如一个进程使用了8MB，那么它使用了$8\text{MB} \div 4\text{KB} = 2^{23} \div 2^{12} = 2^{11} = 2048\text{页}$，每个二级页表可以映射1024页，那么需要两个2级页表，那么总的页表大小是一级页目录4KB，二级页表8KB，共12KB。多级页表实际上是不给那些没有使用的一级页表目录项分配空间，节省了很多空间。

#### 3.2.2 缺页中断

通过`MMU`查到页表中`PFN`标记为`present bit = 0`表示不在物理内存中，CPU会抛出缺页异常`page fault`，操作系统收到后会查询页的存储位置，该页可能在硬盘的`swap`分区或者是`mmap`，`swap`分区中没有文件系统，只是一个用来存放内存页的独立分区，由内核直接管理不通过文件`I/O`，读取直接通过块设备的`I/O`从`swap`到`RAM`。`mmap`要通过文件系统通过`inode`找到对应数据块，然后内核调度块设备`I/O`读取到`RAM`，中间经过了一层文件系统。

`mmap`将文件映射到进程的虚拟地址空间中，但操作系统内核不会立刻把文件内容读入`RAM`，而是在页表里建立一个映射。

然后选择一个物理页框（可能会出现页面置换），读取**硬盘中页数据**到物理内存中，更新页表和`TLB`，标记`presend bit = 1`，然后CPU再次查询`VA`到`PA`成功。

#### 3.2.3 Segmentation Fault

在出现`page fault`之后，如果`PEN`既不在`swap`也不在`mmap`中，就会触发`Segmentation Fault`，操作系统发出`SIGSEGV`的信号终止进程，可能的情况是：

1. 访问未分配的虚拟内存。页表中的`VA`没有合法映射。
2. 页权限冲突。访问已经释放的内存。

#### 3.2.3 虚拟地址空间的优点

1. 每一个进程有认为自己有从`0x00000000`开始的连续地址空间，而每一个进程的实际物理地址空间是完全隔离的。
2. 可以利用硬盘空间来进行内存扩展，允许程序使用比实际物理内存更大的空间。
3. 多个进程访问一个动态链接库`.so`的时候，内核通过`mmap`将文件映射到每个进程的虚拟地址空间，它们共享`.text`和`.rodata`段，对`.data`和`.bss`段，每个进程有自己的副本，使用`COW (Copy-On-Write)`，当进程写入内核会重新分配物理页。
4. 页权限实现内存保护。
5. CPU切换进程的时候，只需要保护现场加切换页表基址寄存器，指向新进程的页表，虚拟地址对于每个进程都是一致的。

#### 3.2.4 碎片

操作系统分配页时按照固定大小，这样就会存在有一些页的内部空间没有被使用，称为内部碎片。而如果采用连续内存分配，那当每个进程的内存释放后，内存都是零碎分散的，无法满足新的连续空间的申请，称之为外部碎片。

### 3.3 访问物理内存

CPU将`PA`放在**地址总线**上，决定访问哪一个存储单元，同时通过**控制总线**告诉内存控制器是读或写操作，内存控制器接收到`PA`之后得到具体的存储单元，然后内存控制器访问`Cache`，如果未命中就从`DRAM`中取数据放回到**数据总线**上，将数据放到`L1/L2/L3 Cache`中，下一次可以直接访问`Cache `而不是`DRAM`了。最终`CPU`都是从`Cache`中读数据到寄存器。

## 4 寄存器宽度

64位系统一般指的就是寄存器宽度为64位，虚拟地址空间的大小和寄存器宽度通常一致，物理地址的最大寻址范围是地址总线决定的，地址总线大小通常和寄存器大小一致。
