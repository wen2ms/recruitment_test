## 🧠 背景理解：为什么会出现“重复请求”问题？

TCP 是基于 IP 的，而 IP 网络本质上是不可靠的，可能出现：

* 网络抖动导致旧的 SYN 包延迟到达
* 客户端重传连接请求（比如第一次 SYN 超时重发）
* 客户端短时间内重新启动，发送了相同的请求

---

## ❓那问题来了：

如果一个**旧的连接请求（SYN 报文）被服务器再次接收**，会不会被服务器错误当成一个**新的连接**？

这就需要我们来看：**三次握手是怎么解决这个问题的**。

---

## ✅ 三次握手如何避免“旧连接请求误建立新连接”？

### 🎬 场景举例：

1. 客户端A和服务器建立连接后关闭，**但第一个 SYN 包因为网络延迟一直没消失**；
2. 客户端A重启后，再次连接服务器，建立了新的连接；
3. **旧的 SYN 包现在才到达服务器**

**如果没有三次握手，服务器可能会误以为这是一个新连接**，就建立了，实际上客户端根本没打算连接 —— 💣 这就是重复连接的问题。

---

### 💡 三次握手中如何避免这个问题？

#### 第一步：

客户端发出 `SYN seq = x`

#### 第二步：

服务器收到后回 `SYN+ACK ack = x+1, seq = y`，**进入 SYN\_RECV 状态**

#### 第三步：

客户端如果不是自己刚刚发的连接，就不会回应 ACK

🔒 服务器**只有在收到客户端的 ACK 后，才会进入 ESTABLISHED 状态，才认为连接正式建立**

---

### 🚫 如果是旧 SYN 包？

旧的 SYN 会触发服务器发 `SYN+ACK`，但客户端根本不会回应，服务器就会在超时后把这个半连接丢弃。

> ✅ 所以即使旧的连接请求被服务器误接收了，也不会导致连接建立！

---

## 🧠 TCP 如何进一步避免重复连接：

除了三次握手，还有两个机制：

### 1. **序列号 ISN（Initial Sequence Number）随机化**

* 每次连接初始序号都不同
* 旧包的序列号无法匹配新连接，不会通过校验

### 2. **连接四元组唯一性**

* 每个连接由：`<源IP, 源端口, 目标IP, 目标端口>` 唯一标识
* 即使是同一客户端再次连接，通常源端口也会变 → 不会被服务器误认为是旧连接

---

## ✅ 总结：

| 机制        | 防止重复连接的作用                       |
| --------- | ------------------------------- |
| 三次握手      | 服务器必须收到最终 ACK 才建立连接，旧 SYN 不会被确认 |
| ISN 随机化   | 旧连接的序列号难以伪造，防止接入新连接             |
| 四元组唯一性    | 防止多个连接混淆                        |
| 半连接队列过期机制 | 旧连接超时自动清理，不建立无效连接               |

---

## 📌 所以你问的“为什么三次握手能防止重复请求”，答案是：

> **三次握手能确保连接只有在双方都确认过后才建立，从而避免了“旧 SYN”或“重复连接请求”被服务器错误接受的问题。**
