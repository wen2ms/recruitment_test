# 1. DNS

`DNS (Domain Name System)`将域名转化为`IP`地址。

当访问`google.com`时域名解析的过程是：浏览器检查是否有刚刚缓存的`google.com`对应的`IP`，如果没有命中，浏览器就会通过系统调用查询操作系统的`DNS`缓存中是否有对应的`IP`，如果也没有命中，接着查询`/etc/hosts`中对应的`IP`，例如`127.0.0.1 localhost 255.255.255.255 broadcasthost`。

如果以上都没有命中，那么操作系统会向本地配置的多个`DNS`服务器发起基于`UDP`发起单播请求，例如`nameserver 114.114.114.114`，递归查询，本地`DNS`服务器请求根`DNS`服务器得到`.com`顶级域名服务器。本地服务器再向顶级域名服务器发起请求得到权威域名服务器地址。最后再向权威域名服务器请求得到对应的`IP`地址。本地服务器再将`IP`返回给操作系统，操作系统缓存`DNS`后，将`IP`返回浏览器，然后浏览器可以进行`HTTP`请求了。

最常见的`DNS劫持`是发生在本地`DNS`服务器与查询的`DNS`服务器之间，有中间设备劫持了`DNS`数据包并伪造响应，注入一个错误的`IP`。

# 2. HTTP

`HTTP (HyperText Transfer Protocol)`超文本传输协议是基于`TCP/IP`的应用层协议。`HTTP`是`C/S`架构，它的基本流程在建立完下层连接后，客户端发送`HTTP Request`，服务器接收，处理请求报文并返回`HTTP Response`，最后客户端解析响应报文，并渲染网页。

## 2.1 HTTP Request

`HTTP`请求报文结构是：

```
请求行Request Line
请求头Request Headers
空行
请求体Request Body
```

实际`HTTP`在应用层传输也是一个字节流，每个部分通过`\r\n`来分割。最后的请求体是可选字段。请求行包括请求方法，用一个空格和请求路径分隔，再一个空格表示`HTTP`协议的版本。请求头中最重要的信息就是`Host`代表`IP`，请求头中包含若干个键值对，每个键值对也也用`\r\n`来分隔，其中`Content-Length`就可以用来判断请求体是否结束，`Content-Type`可以表示请求体的格式，例如`text/plain`表示纯文本，`text/html`表示一个`HTML`页面等。

```sh
GET / HTTP/1.1\r\nHost: 127.0.0.1:8080\r\n\r\n
```

## 2.2 HTTP Response

`HTTP`响应报文结构是：

```
状态行Status Line
响应头Response Headers
响应体Response Body
```

状态行最重要的就是状态码和状态描述，常见的情况：请求成功一般是：

`200 OK`，也会出现其他`20x`一般都表示请求成功。

`301 Moved Permanently`表示永久重定向，例如访问`curl -v google.com`就会出现。

`403 Forbidden`表示禁止访问，是指客户端请求合法，但是服务器拒绝。

`405 Method Not Allowed`表示客户端的请求方式不对，例如`curl -XPost -v google.com`。

`404 Not Found`表示客户端请求的资源不存在，例如`curl -v google.com/1`。

`422 Unprocessable Entity`校验时请求的参数不合法。

`500 Internal Server Error`表示服务器内部错误，例如请求这个服务时服务器崩溃。

```
HTTP/1.1 200 OK\r\nContent-Length: 25\r\n\r\n{"message":"Hello World"}
```

响应头和请求头一致，包含多个键值对。

## 2.3 HTTP的特点

`HTTP`协议是连接无状态的，服务端不存储客户端状态，每次请求都是独立。对于同一个`TCP`连接，客户端可以异步发送请求。

对于`HTTP/1.1`没有请求编号，所以服务端的响应必须按照请求顺序同步回复，无法并发。但这就引起了服务端的`队头阻塞`，在客户端可以异步的发送请求，但他们共用一个`TCP`连接，后面的请求对应的响应，必须要在前面请求的响应完成后才能发送，导致客户端感到延迟。

`HTTP`传输的数据是`ASCII`字符串，在网络中以明文形式传输。它默认使用`80`端口。

## 2.4 HTTP/2

一般我们指`HTTP`是`HTTP/1.1`，但是`HTTP/1.1`存在队头阻塞问题，为了解决这个问题，浏览器会对每个`IP`创建一个`TCP`连接池来保证并发，但这同时也增加了三次握手开销和内存占用，而`HTTP/2`通过加入请求编号，彻底解决`HTTP/1.1`的顺序响应带来的队头阻塞。同时`HTTP/2`是一个二进制协议，它将每个请求作为一个二进制帧，多个合并在一起通过一个`TCP`连接发送，而服务端根据编号重新整理出请求，实现了多路并发。

同时压缩了请求头`Headers`首部信息，效率更高。

# 3. TLS

`TLS (Transport Layer Security)`传输层安全协议，它是在表示层，主要是为了给`HTTP`传输的数据加密，也就是`HTTPS`。

首先明确非对称加密保密性高，就是一个公钥对应一个私钥，但效率低，而对称加密双方都使用一个公钥进行加解密，效率高，但不安全。`TLS`握手就是解决这个问题。

它的主要过程是：

1. 客户端发送自己支持的加密算法列表，`TLS`版本，随机数。
2. 服务端选择加密算法，返回自己的`CA`证书，这其中包括公钥，以及随机数。
3. 客户端通过`CA`根证书验证服务端证书的合法性。
4. 客户端生成一个预主密钥`pre-master key`，基于随机数和服务端的公钥加密后传输给服务端。
5. 服务端通过基于随机数和私钥解密后也得到对称加密的密钥，双方之后的所有数据，包括`HTTP`连接建立，都通过这个对称密钥加密。

`https`的默认端口是`443`。

浏览器从输入`URL`到页面显示，要经过浏览器解析`URL`，得到协议，主机名，路径，然后`DNS`解析得到`IP`，然后浏览器依次在传输层发起三次握手建立`TCP`连接，在表示层发起`TLS`握手，在应用层发起`HTTP`请求，在服务端收到后报文后处理并返回给浏览器`HTML`页面或者其他格式的数据，最后浏览器解析响应的内容并且渲染页面，如果数据是跨域资源还会递归进行请求。

