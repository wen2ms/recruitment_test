`epoll` 和 `select` 都是 I/O 多路复用技术，用于处理多个文件描述符的输入输出事件。但它们之间有几个重要的区别，`epoll` 在高并发场景下比 `select` 更高效，原因如下：

### 1. **文件描述符限制**

* **select**：`select` 的最大文件描述符数量是有限制的（通常是 1024）。这个限制由操作系统的 `FD_SETSIZE` 定义。如果应用需要监控大量的文件描述符，这个限制会带来不便。
* **epoll**：`epoll` 没有这样的限制，理论上可以处理上万甚至更多的文件描述符。

### 2. **性能差异**

* **select**：每次调用时，`select` 都需要扫描所有的文件描述符集合，这样即使有很多文件描述符没有变化，`select` 依然会遍历它们，消耗更多的 CPU 时间。因此，随着文件描述符数量的增加，性能会逐渐下降。
* **epoll**：`epoll` 是基于事件驱动的，它只会处理那些已经准备好的文件描述符（即那些发生了事件的文件描述符）。在文件描述符数量增多时，`epoll` 依然保持高效，因为它只返回有事件发生的文件描述符，而不是遍历所有文件描述符。

### 3. **内存使用**

* **select**：每次调用时，`select` 都需要重新构造文件描述符集合，这需要在每次调用时进行内存复制，增加了内存的消耗。
* **epoll**：`epoll` 的操作是基于内核的事件通知机制，内核只在有事件发生时通知用户空间，而不需要频繁地复制文件描述符集合。这样在内存使用上更加高效。

### 4. **调用开销**

* **select**：每次调用时，`select` 会将文件描述符集合从用户空间复制到内核空间，操作频繁，性能较差。
* **epoll**：`epoll` 提供了 `epoll_ctl` 来添加、删除文件描述符，并通过 `epoll_wait` 获取事件。这些操作不会在每次调用时复制文件描述符集合，减少了调用开销。

### 5. **工作模式**

* **select**：是基于轮询的，每次都会扫描所有的文件描述符，效率随着文件描述符数的增加而下降。
* **epoll**：支持两种工作模式：`水平触发`（Level-Triggered）和`边缘触发`（Edge-Triggered）。`边缘触发`模式在文件描述符状态发生变化时通知应用，不会重复通知，进一步减少了不必要的操作。

### 6. **适用场景**

* **select**：适用于文件描述符数量相对较小的场景，或者对于一些老旧系统或代码兼容性要求较高的场景。
* **epoll**：适用于高并发、大量连接的场景，能够高效地处理成千上万的文件描述符。

### 总结

`epoll` 相比 `select` 更高效的原因在于它基于事件通知，只处理有事件发生的文件描述符，避免了不必要的遍历和内存复制。并且它没有文件描述符数量的限制，适合大规模的并发处理。

---

### 🔁 问题背景再回顾一下：

* 在 **`epoll` 的 ET（边缘触发）模式下**，**内核只在状态“从不可读变为可读”的瞬间**发送一次 `EPOLLIN` 通知。
* 之后即使还有数据可读（比如你没一次性读完），**也不会再触发通知**，直到**新的数据**到达，造成状态变化。

---

1. **阻止程序继续处理事件**：

   * 如果你用的是**阻塞 socket**，你在收到一次 `EPOLLIN` 通知后，去调用 `recv()`，但由于数据还没准备好，或数据被分多次发送，你**可能会阻塞在 `recv()` 上**。
   * **这时程序就卡住了**，因为你还在 `recv()` 那里等着数据。

2. **更严重的问题是：** 在 ET 模式下，内核**不会再通知你新的 `EPOLLIN` 事件**，即使后续有数据到了也不会再唤醒 `epoll_wait()`。

   * 因为 ET 模式下，内核的逻辑是：“你已经被通知过这个 fd 可读了，之后你自己应该一直读，直到没有数据了（返回 EAGAIN）为止。”
   * 如果你用阻塞 `recv()` 只读一部分就退出循环，**你错过了继续读的机会，下一次也收不到通知了**。

---

### ❗结果就是：

* 如果你在 `recv()` 中阻塞了，主线程就卡住了；
* 如果你没读完，又退出了读取循环（并且没返回 EAGAIN），内核认为你已经知道这个 fd 可读了，就不会再次通知你；
* 下一次 `epoll_wait()` 根本不会返回这个 fd，**你再也不会知道有数据来了**，造成“程序假死”。

---

### ✅ 正确做法总结

* 设置 socket 为**非阻塞模式**
* 在 ET 模式下，在收到 `EPOLLIN` 之后，**不停地调用 `recv()` 直到返回 `EAGAIN`**，说明数据已经全部读取完了
* 只有这样你才能保证不会丢事件，也不会让程序卡住

---

### 📌 重点结论

> ✅ **epoll\_wait 是不会被阻塞的**，真正的问题是：**你在 ET 模式下没有读完所有数据、又没设置非阻塞，程序卡在 `recv()` 里**，而且 **你不会再收到下一次通知**，导致后续数据丢失，程序“看起来像卡死了一样”。

---
