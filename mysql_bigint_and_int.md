## ✅ MySQL 整数类型对比表：

| 类型          | 字节数 | 有符号范围（SIGNED）                                          | 无符号范围（UNSIGNED）                |
| ----------- | --- | ------------------------------------------------------ | ------------------------------ |
| TINYINT     | 1   | -128 到 127                                             | 0 到 255                        |
| SMALLINT    | 2   | -32,768 到 32,767                                       | 0 到 65,535                     |
| MEDIUMINT   | 3   | -8,388,608 到 8,388,607                                 | 0 到 16,777,215                 |
| INT/INTEGER | 4   | -2,147,483,648 到 2,147,483,647                         | 0 到 4,294,967,295              |
| BIGINT      | 8   | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0 到 18,446,744,073,709,551,615 |

---

### 📌 INT vs BIGINT(int 和 long)

| 比较项   | `INT` 类型  | `BIGINT` 类型        |
| ----- | --------- | ------------------ |
| 字节数   | 4 字节（32位） | 8 字节（64位）          |
| 有符号范围 | ±21亿左右    | ±9千万亿左右            |
| 存储空间  | 小，效率稍高    | 大，占用空间多            |
| 应用场景  | 计数器、状态、ID | 超大 ID、财务金额、长整型唯一标识 |

---

### 🔒 补充说明：

* MySQL 没有 `long` 类型，C/C++ 中的 `long` 相当于 MySQL 的 `BIGINT`。
* `UNSIGNED` 修饰可以让类型只存储非负数，扩大上限范围。
* `ZEROFILL` 只是用于显示前导零（如 `000123`），不影响实际数值大小。
* `AUTO_INCREMENT` 字段建议用 `BIGINT UNSIGNED`（避免日后爆表）。

---

### ✅ 选择建议：

| 使用场景           | 推荐类型              |
| -------------- | ----------------- |
| 小范围状态（0\~255）  | `TINYINT`         |
| 普通自增主键         | `INT UNSIGNED`    |
| 海量数据主键         | `BIGINT UNSIGNED` |
| 金额、交易ID、长GUID等 | `BIGINT`          |

---
